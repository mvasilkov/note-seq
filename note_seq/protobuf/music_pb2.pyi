"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class NoteSequence(google.protobuf.message.Message):
    """A message containing a symbolic music sequence. The design is largely
    based on MIDI but it should be able to represent any music sequence.
    For details see https://www.midi.org/specifications.
    Note that repeated fields in this proto are not guaranteed to be sorted
    by time.
    Next tag: 22
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _PitchName:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PitchNameEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence._PitchName.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_PITCH_NAME: NoteSequence._PitchName.ValueType  # 0
        F_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 1
        C_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 2
        G_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 3
        D_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 4
        A_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 5
        E_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 6
        B_FLAT_FLAT: NoteSequence._PitchName.ValueType  # 7
        F_FLAT: NoteSequence._PitchName.ValueType  # 8
        C_FLAT: NoteSequence._PitchName.ValueType  # 9
        G_FLAT: NoteSequence._PitchName.ValueType  # 10
        D_FLAT: NoteSequence._PitchName.ValueType  # 11
        A_FLAT: NoteSequence._PitchName.ValueType  # 12
        E_FLAT: NoteSequence._PitchName.ValueType  # 13
        B_FLAT: NoteSequence._PitchName.ValueType  # 14
        F: NoteSequence._PitchName.ValueType  # 15
        C: NoteSequence._PitchName.ValueType  # 16
        G: NoteSequence._PitchName.ValueType  # 17
        D: NoteSequence._PitchName.ValueType  # 18
        A: NoteSequence._PitchName.ValueType  # 19
        E: NoteSequence._PitchName.ValueType  # 20
        B: NoteSequence._PitchName.ValueType  # 21
        F_SHARP: NoteSequence._PitchName.ValueType  # 22
        C_SHARP: NoteSequence._PitchName.ValueType  # 23
        G_SHARP: NoteSequence._PitchName.ValueType  # 24
        D_SHARP: NoteSequence._PitchName.ValueType  # 25
        A_SHARP: NoteSequence._PitchName.ValueType  # 26
        E_SHARP: NoteSequence._PitchName.ValueType  # 27
        B_SHARP: NoteSequence._PitchName.ValueType  # 28
        F_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 29
        C_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 30
        G_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 31
        D_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 32
        A_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 33
        E_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 34
        B_SHARP_SHARP: NoteSequence._PitchName.ValueType  # 35
    class PitchName(_PitchName, metaclass=_PitchNameEnumTypeWrapper):
        """Adopted from Musescore with start enum shifted to 0; see
        https://musescore.org/en/plugin-development/tonal-pitch-class-enum
        for details.
        """
        pass

    UNKNOWN_PITCH_NAME: NoteSequence.PitchName.ValueType  # 0
    F_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 1
    C_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 2
    G_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 3
    D_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 4
    A_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 5
    E_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 6
    B_FLAT_FLAT: NoteSequence.PitchName.ValueType  # 7
    F_FLAT: NoteSequence.PitchName.ValueType  # 8
    C_FLAT: NoteSequence.PitchName.ValueType  # 9
    G_FLAT: NoteSequence.PitchName.ValueType  # 10
    D_FLAT: NoteSequence.PitchName.ValueType  # 11
    A_FLAT: NoteSequence.PitchName.ValueType  # 12
    E_FLAT: NoteSequence.PitchName.ValueType  # 13
    B_FLAT: NoteSequence.PitchName.ValueType  # 14
    F: NoteSequence.PitchName.ValueType  # 15
    C: NoteSequence.PitchName.ValueType  # 16
    G: NoteSequence.PitchName.ValueType  # 17
    D: NoteSequence.PitchName.ValueType  # 18
    A: NoteSequence.PitchName.ValueType  # 19
    E: NoteSequence.PitchName.ValueType  # 20
    B: NoteSequence.PitchName.ValueType  # 21
    F_SHARP: NoteSequence.PitchName.ValueType  # 22
    C_SHARP: NoteSequence.PitchName.ValueType  # 23
    G_SHARP: NoteSequence.PitchName.ValueType  # 24
    D_SHARP: NoteSequence.PitchName.ValueType  # 25
    A_SHARP: NoteSequence.PitchName.ValueType  # 26
    E_SHARP: NoteSequence.PitchName.ValueType  # 27
    B_SHARP: NoteSequence.PitchName.ValueType  # 28
    F_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 29
    C_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 30
    G_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 31
    D_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 32
    A_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 33
    E_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 34
    B_SHARP_SHARP: NoteSequence.PitchName.ValueType  # 35

    class Note(google.protobuf.message.Message):
        """Next tag: 15"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        PITCH_FIELD_NUMBER: builtins.int
        PITCH_NAME_FIELD_NUMBER: builtins.int
        VELOCITY_FIELD_NUMBER: builtins.int
        START_TIME_FIELD_NUMBER: builtins.int
        QUANTIZED_START_STEP_FIELD_NUMBER: builtins.int
        END_TIME_FIELD_NUMBER: builtins.int
        QUANTIZED_END_STEP_FIELD_NUMBER: builtins.int
        NUMERATOR_FIELD_NUMBER: builtins.int
        DENOMINATOR_FIELD_NUMBER: builtins.int
        INSTRUMENT_FIELD_NUMBER: builtins.int
        PROGRAM_FIELD_NUMBER: builtins.int
        IS_DRUM_FIELD_NUMBER: builtins.int
        PART_FIELD_NUMBER: builtins.int
        VOICE_FIELD_NUMBER: builtins.int
        pitch: builtins.int
        """MIDI pitch; see en.wikipedia.org/wiki/MIDI_Tuning_Standard for details."""

        pitch_name: global___NoteSequence.PitchName.ValueType
        """The notated pitch spelling in the score."""

        velocity: builtins.int
        """Velocity ranging between 0 and 127."""

        start_time: builtins.float
        """Start time in seconds."""

        quantized_start_step: builtins.int
        """Quantized start time in steps."""

        end_time: builtins.float
        """End time in seconds."""

        quantized_end_step: builtins.int
        """Quantized end time in steps."""

        numerator: builtins.int
        """Score-relative note length. E.g. a quarter note is 1/4."""

        denominator: builtins.int
        instrument: builtins.int
        """For MIDI source data, an instrument stores all events in a track having
        the same program and channel, as done by pretty-midi.
        """

        program: builtins.int
        """A program selects an instrument's sound.
        Note that the General MIDI documentation is 1-based, but this field is
        0-based. So GM documents program 12 as vibraphone, but this field would
        be set to 11 for that instrument.
        See www.midi.org/specifications/item/gm-level-1-sound-set.
        """

        is_drum: builtins.bool
        """When true, the event is on an instrument that is a drum (MIDI channel 9)."""

        part: builtins.int
        """The part index if this came from a score. Otherwise, just 0.
        For example, a score may have separate parts for different instruments in
        an orchestra.
        If additional information is available about the part, a corresponding
        PartInfo should be defined with the same index.
        """

        voice: builtins.int
        """The voice index if this came from a score. Otherwise, just 0.
        For example, within a part, there may be multiple voices (e.g., Soprano,
        Alto, Tenor, Bass).
        Note that while voices indexes must be unique within a part, they are not
        guaranteed to be unique across parts.
        """

        def __init__(self,
            *,
            pitch: builtins.int = ...,
            pitch_name: global___NoteSequence.PitchName.ValueType = ...,
            velocity: builtins.int = ...,
            start_time: builtins.float = ...,
            quantized_start_step: builtins.int = ...,
            end_time: builtins.float = ...,
            quantized_end_step: builtins.int = ...,
            numerator: builtins.int = ...,
            denominator: builtins.int = ...,
            instrument: builtins.int = ...,
            program: builtins.int = ...,
            is_drum: builtins.bool = ...,
            part: builtins.int = ...,
            voice: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["denominator",b"denominator","end_time",b"end_time","instrument",b"instrument","is_drum",b"is_drum","numerator",b"numerator","part",b"part","pitch",b"pitch","pitch_name",b"pitch_name","program",b"program","quantized_end_step",b"quantized_end_step","quantized_start_step",b"quantized_start_step","start_time",b"start_time","velocity",b"velocity","voice",b"voice"]) -> None: ...

    class TimeSignature(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIME_FIELD_NUMBER: builtins.int
        NUMERATOR_FIELD_NUMBER: builtins.int
        DENOMINATOR_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        numerator: builtins.int
        denominator: builtins.int
        def __init__(self,
            *,
            time: builtins.float = ...,
            numerator: builtins.int = ...,
            denominator: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["denominator",b"denominator","numerator",b"numerator","time",b"time"]) -> None: ...

    class KeySignature(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Key:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _KeyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.KeySignature._Key.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            C: NoteSequence.KeySignature._Key.ValueType  # 0
            C_SHARP: NoteSequence.KeySignature._Key.ValueType  # 1
            D_FLAT: NoteSequence.KeySignature._Key.ValueType  # 1
            D: NoteSequence.KeySignature._Key.ValueType  # 2
            D_SHARP: NoteSequence.KeySignature._Key.ValueType  # 3
            E_FLAT: NoteSequence.KeySignature._Key.ValueType  # 3
            E: NoteSequence.KeySignature._Key.ValueType  # 4
            F: NoteSequence.KeySignature._Key.ValueType  # 5
            F_SHARP: NoteSequence.KeySignature._Key.ValueType  # 6
            G_FLAT: NoteSequence.KeySignature._Key.ValueType  # 6
            G: NoteSequence.KeySignature._Key.ValueType  # 7
            G_SHARP: NoteSequence.KeySignature._Key.ValueType  # 8
            A_FLAT: NoteSequence.KeySignature._Key.ValueType  # 8
            A: NoteSequence.KeySignature._Key.ValueType  # 9
            A_SHARP: NoteSequence.KeySignature._Key.ValueType  # 10
            B_FLAT: NoteSequence.KeySignature._Key.ValueType  # 10
            B: NoteSequence.KeySignature._Key.ValueType  # 11
        class Key(_Key, metaclass=_KeyEnumTypeWrapper):
            pass

        C: NoteSequence.KeySignature.Key.ValueType  # 0
        C_SHARP: NoteSequence.KeySignature.Key.ValueType  # 1
        D_FLAT: NoteSequence.KeySignature.Key.ValueType  # 1
        D: NoteSequence.KeySignature.Key.ValueType  # 2
        D_SHARP: NoteSequence.KeySignature.Key.ValueType  # 3
        E_FLAT: NoteSequence.KeySignature.Key.ValueType  # 3
        E: NoteSequence.KeySignature.Key.ValueType  # 4
        F: NoteSequence.KeySignature.Key.ValueType  # 5
        F_SHARP: NoteSequence.KeySignature.Key.ValueType  # 6
        G_FLAT: NoteSequence.KeySignature.Key.ValueType  # 6
        G: NoteSequence.KeySignature.Key.ValueType  # 7
        G_SHARP: NoteSequence.KeySignature.Key.ValueType  # 8
        A_FLAT: NoteSequence.KeySignature.Key.ValueType  # 8
        A: NoteSequence.KeySignature.Key.ValueType  # 9
        A_SHARP: NoteSequence.KeySignature.Key.ValueType  # 10
        B_FLAT: NoteSequence.KeySignature.Key.ValueType  # 10
        B: NoteSequence.KeySignature.Key.ValueType  # 11

        class _Mode:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.KeySignature._Mode.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            MAJOR: NoteSequence.KeySignature._Mode.ValueType  # 0
            MINOR: NoteSequence.KeySignature._Mode.ValueType  # 1
            NOT_SPECIFIED: NoteSequence.KeySignature._Mode.ValueType  # 2
            MIXOLYDIAN: NoteSequence.KeySignature._Mode.ValueType  # 3
            DORIAN: NoteSequence.KeySignature._Mode.ValueType  # 4
            PHRYGIAN: NoteSequence.KeySignature._Mode.ValueType  # 5
            LYDIAN: NoteSequence.KeySignature._Mode.ValueType  # 6
            LOCRIAN: NoteSequence.KeySignature._Mode.ValueType  # 7
        class Mode(_Mode, metaclass=_ModeEnumTypeWrapper):
            pass

        MAJOR: NoteSequence.KeySignature.Mode.ValueType  # 0
        MINOR: NoteSequence.KeySignature.Mode.ValueType  # 1
        NOT_SPECIFIED: NoteSequence.KeySignature.Mode.ValueType  # 2
        MIXOLYDIAN: NoteSequence.KeySignature.Mode.ValueType  # 3
        DORIAN: NoteSequence.KeySignature.Mode.ValueType  # 4
        PHRYGIAN: NoteSequence.KeySignature.Mode.ValueType  # 5
        LYDIAN: NoteSequence.KeySignature.Mode.ValueType  # 6
        LOCRIAN: NoteSequence.KeySignature.Mode.ValueType  # 7

        TIME_FIELD_NUMBER: builtins.int
        KEY_FIELD_NUMBER: builtins.int
        MODE_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        key: global___NoteSequence.KeySignature.Key.ValueType
        mode: global___NoteSequence.KeySignature.Mode.ValueType
        def __init__(self,
            *,
            time: builtins.float = ...,
            key: global___NoteSequence.KeySignature.Key.ValueType = ...,
            mode: global___NoteSequence.KeySignature.Mode.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","mode",b"mode","time",b"time"]) -> None: ...

    class Tempo(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIME_FIELD_NUMBER: builtins.int
        QPM_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds when tempo goes into effect."""

        qpm: builtins.float
        """Tempo in quarter notes per minute."""

        def __init__(self,
            *,
            time: builtins.float = ...,
            qpm: builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["qpm",b"qpm","time",b"time"]) -> None: ...

    class PitchBend(google.protobuf.message.Message):
        """Stores MIDI PitchBend data. See the MIDI specification for details."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIME_FIELD_NUMBER: builtins.int
        BEND_FIELD_NUMBER: builtins.int
        INSTRUMENT_FIELD_NUMBER: builtins.int
        PROGRAM_FIELD_NUMBER: builtins.int
        IS_DRUM_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        bend: builtins.int
        """Pitch bend amount in the range (-8192, 8191)."""

        instrument: builtins.int
        program: builtins.int
        is_drum: builtins.bool
        def __init__(self,
            *,
            time: builtins.float = ...,
            bend: builtins.int = ...,
            instrument: builtins.int = ...,
            program: builtins.int = ...,
            is_drum: builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["bend",b"bend","instrument",b"instrument","is_drum",b"is_drum","program",b"program","time",b"time"]) -> None: ...

    class ControlChange(google.protobuf.message.Message):
        """Stores MIDI Control Change data. See the MIDI specification for details."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIME_FIELD_NUMBER: builtins.int
        QUANTIZED_STEP_FIELD_NUMBER: builtins.int
        CONTROL_NUMBER_FIELD_NUMBER: builtins.int
        CONTROL_VALUE_FIELD_NUMBER: builtins.int
        INSTRUMENT_FIELD_NUMBER: builtins.int
        PROGRAM_FIELD_NUMBER: builtins.int
        IS_DRUM_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        quantized_step: builtins.int
        """Quantized time in steps."""

        control_number: builtins.int
        """Control (or "controller") number e.g. 0x4 = Foot Controller."""

        control_value: builtins.int
        """The value for that controller in the range (0, 127)."""

        instrument: builtins.int
        program: builtins.int
        is_drum: builtins.bool
        def __init__(self,
            *,
            time: builtins.float = ...,
            quantized_step: builtins.int = ...,
            control_number: builtins.int = ...,
            control_value: builtins.int = ...,
            instrument: builtins.int = ...,
            program: builtins.int = ...,
            is_drum: builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["control_number",b"control_number","control_value",b"control_value","instrument",b"instrument","is_drum",b"is_drum","program",b"program","quantized_step",b"quantized_step","time",b"time"]) -> None: ...

    class PartInfo(google.protobuf.message.Message):
        """Stores score-related information about a particular part.
        See usage within Note for more details.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        PART_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        part: builtins.int
        """The part index."""

        name: typing.Text
        """The name of the part. Examples: "Piano" or "Voice"."""

        def __init__(self,
            *,
            part: builtins.int = ...,
            name: typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","part",b"part"]) -> None: ...

    class InstrumentInfo(google.protobuf.message.Message):
        """Stores information about an instrument name
        See usage within Note for more details.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        INSTRUMENT_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        instrument: builtins.int
        """The instrument index."""

        name: typing.Text
        """The name of the instrument. Examples: "Piano" or "bass"."""

        def __init__(self,
            *,
            instrument: builtins.int = ...,
            name: typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["instrument",b"instrument","name",b"name"]) -> None: ...

    class SourceInfo(google.protobuf.message.Message):
        """Stores source-related information."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _SourceType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _SourceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.SourceInfo._SourceType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNKNOWN_SOURCE_TYPE: NoteSequence.SourceInfo._SourceType.ValueType  # 0
            SCORE_BASED: NoteSequence.SourceInfo._SourceType.ValueType  # 1
            """If the source was some kind of score (e.g., MusicXML, ABC, etc.).
            We can expect perfect timing alignment with measures and complete
            TimeSignature and KeySignature information.
            """

            PERFORMANCE_BASED: NoteSequence.SourceInfo._SourceType.ValueType  # 2
        class SourceType(_SourceType, metaclass=_SourceTypeEnumTypeWrapper):
            """The type of source that was encoded in the original file."""
            pass

        UNKNOWN_SOURCE_TYPE: NoteSequence.SourceInfo.SourceType.ValueType  # 0
        SCORE_BASED: NoteSequence.SourceInfo.SourceType.ValueType  # 1
        """If the source was some kind of score (e.g., MusicXML, ABC, etc.).
        We can expect perfect timing alignment with measures and complete
        TimeSignature and KeySignature information.
        """

        PERFORMANCE_BASED: NoteSequence.SourceInfo.SourceType.ValueType  # 2

        class _EncodingType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _EncodingTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.SourceInfo._EncodingType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNKNOWN_ENCODING_TYPE: NoteSequence.SourceInfo._EncodingType.ValueType  # 0
            MUSIC_XML: NoteSequence.SourceInfo._EncodingType.ValueType  # 1
            ABC: NoteSequence.SourceInfo._EncodingType.ValueType  # 2
            MIDI: NoteSequence.SourceInfo._EncodingType.ValueType  # 3
            MUSICNET: NoteSequence.SourceInfo._EncodingType.ValueType  # 4
        class EncodingType(_EncodingType, metaclass=_EncodingTypeEnumTypeWrapper):
            """Enum for all encoding types, both score_based and performance_based."""
            pass

        UNKNOWN_ENCODING_TYPE: NoteSequence.SourceInfo.EncodingType.ValueType  # 0
        MUSIC_XML: NoteSequence.SourceInfo.EncodingType.ValueType  # 1
        ABC: NoteSequence.SourceInfo.EncodingType.ValueType  # 2
        MIDI: NoteSequence.SourceInfo.EncodingType.ValueType  # 3
        MUSICNET: NoteSequence.SourceInfo.EncodingType.ValueType  # 4

        class _Parser:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ParserEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.SourceInfo._Parser.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNKNOWN_PARSER: NoteSequence.SourceInfo._Parser.ValueType  # 0
            MUSIC21: NoteSequence.SourceInfo._Parser.ValueType  # 1
            PRETTY_MIDI: NoteSequence.SourceInfo._Parser.ValueType  # 2
            MAGENTA_MUSIC_XML: NoteSequence.SourceInfo._Parser.ValueType  # 3
            """Magenta's built-in MusicXML parser."""

            MAGENTA_MUSICNET: NoteSequence.SourceInfo._Parser.ValueType  # 4
            """Magenta's parser for MusicNet data."""

            MAGENTA_ABC: NoteSequence.SourceInfo._Parser.ValueType  # 5
            """Magenta's parser for ABC files."""

            TONEJS_MIDI_CONVERT: NoteSequence.SourceInfo._Parser.ValueType  # 6
            """Javascript Tonejs/MidiConvert."""

        class Parser(_Parser, metaclass=_ParserEnumTypeWrapper):
            """Name of parser used to parse the source file."""
            pass

        UNKNOWN_PARSER: NoteSequence.SourceInfo.Parser.ValueType  # 0
        MUSIC21: NoteSequence.SourceInfo.Parser.ValueType  # 1
        PRETTY_MIDI: NoteSequence.SourceInfo.Parser.ValueType  # 2
        MAGENTA_MUSIC_XML: NoteSequence.SourceInfo.Parser.ValueType  # 3
        """Magenta's built-in MusicXML parser."""

        MAGENTA_MUSICNET: NoteSequence.SourceInfo.Parser.ValueType  # 4
        """Magenta's parser for MusicNet data."""

        MAGENTA_ABC: NoteSequence.SourceInfo.Parser.ValueType  # 5
        """Magenta's parser for ABC files."""

        TONEJS_MIDI_CONVERT: NoteSequence.SourceInfo.Parser.ValueType  # 6
        """Javascript Tonejs/MidiConvert."""


        SOURCE_TYPE_FIELD_NUMBER: builtins.int
        ENCODING_TYPE_FIELD_NUMBER: builtins.int
        PARSER_FIELD_NUMBER: builtins.int
        source_type: global___NoteSequence.SourceInfo.SourceType.ValueType
        """The type of source, if it was score-based or performance-based."""

        encoding_type: global___NoteSequence.SourceInfo.EncodingType.ValueType
        """The encoding type used in the source file."""

        parser: global___NoteSequence.SourceInfo.Parser.ValueType
        """That parser that was used to parse the source file."""

        def __init__(self,
            *,
            source_type: global___NoteSequence.SourceInfo.SourceType.ValueType = ...,
            encoding_type: global___NoteSequence.SourceInfo.EncodingType.ValueType = ...,
            parser: global___NoteSequence.SourceInfo.Parser.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["encoding_type",b"encoding_type","parser",b"parser","source_type",b"source_type"]) -> None: ...

    class TextAnnotation(google.protobuf.message.Message):
        """Stores an arbitrary text annotation associated with a point in time.
        Next tag: 5
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _TextAnnotationType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _TextAnnotationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NoteSequence.TextAnnotation._TextAnnotationType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNKNOWN: NoteSequence.TextAnnotation._TextAnnotationType.ValueType  # 0
            """Unknown annotation type."""

            CHORD_SYMBOL: NoteSequence.TextAnnotation._TextAnnotationType.ValueType  # 1
            """Chord symbol as used in lead sheets. We treat text as the "ground
            truth" format for chord symbols, as the semantic interpretation of
            a chord symbol is often fuzzy. We defer this interpretation to
            individual models, each of which can translate chord symbol strings
            into model input in whatever way is deemed most appropriate for that
            model.

            Some examples of chord symbol text we consider reasonable: 'C#', 'A7',
            'Fm7b5', 'N.C.', 'G(no3)', 'C/Bb', 'D-9(b5)', 'Gadd2', 'Abm(maj7)'.
            """

            BEAT: NoteSequence.TextAnnotation._TextAnnotationType.ValueType  # 2
            """Annotation used to indicate a "beat" within a performance. This is
            useful when beat information cannot be derived from the time signature
            and tempo, as is the case for live performances.
            This annotation does not imply that the beat is a downbeat, and it is
            undefined what kind of metrical value the beat has (e.g., quarter
            note).
            The text content of this annotation can be application-specific.
            """

        class TextAnnotationType(_TextAnnotationType, metaclass=_TextAnnotationTypeEnumTypeWrapper):
            pass

        UNKNOWN: NoteSequence.TextAnnotation.TextAnnotationType.ValueType  # 0
        """Unknown annotation type."""

        CHORD_SYMBOL: NoteSequence.TextAnnotation.TextAnnotationType.ValueType  # 1
        """Chord symbol as used in lead sheets. We treat text as the "ground
        truth" format for chord symbols, as the semantic interpretation of
        a chord symbol is often fuzzy. We defer this interpretation to
        individual models, each of which can translate chord symbol strings
        into model input in whatever way is deemed most appropriate for that
        model.

        Some examples of chord symbol text we consider reasonable: 'C#', 'A7',
        'Fm7b5', 'N.C.', 'G(no3)', 'C/Bb', 'D-9(b5)', 'Gadd2', 'Abm(maj7)'.
        """

        BEAT: NoteSequence.TextAnnotation.TextAnnotationType.ValueType  # 2
        """Annotation used to indicate a "beat" within a performance. This is
        useful when beat information cannot be derived from the time signature
        and tempo, as is the case for live performances.
        This annotation does not imply that the beat is a downbeat, and it is
        undefined what kind of metrical value the beat has (e.g., quarter
        note).
        The text content of this annotation can be application-specific.
        """


        TIME_FIELD_NUMBER: builtins.int
        QUANTIZED_STEP_FIELD_NUMBER: builtins.int
        TEXT_FIELD_NUMBER: builtins.int
        ANNOTATION_TYPE_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        quantized_step: builtins.int
        """Quantized time in steps."""

        text: typing.Text
        """Text of the annotation."""

        annotation_type: global___NoteSequence.TextAnnotation.TextAnnotationType.ValueType
        """Type of the annotation, to assist with automated interpretation."""

        def __init__(self,
            *,
            time: builtins.float = ...,
            quantized_step: builtins.int = ...,
            text: typing.Text = ...,
            annotation_type: global___NoteSequence.TextAnnotation.TextAnnotationType.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["annotation_type",b"annotation_type","quantized_step",b"quantized_step","text",b"text","time",b"time"]) -> None: ...

    class QuantizationInfo(google.protobuf.message.Message):
        """Information about how/if this sequence was quantized."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        STEPS_PER_QUARTER_FIELD_NUMBER: builtins.int
        STEPS_PER_SECOND_FIELD_NUMBER: builtins.int
        steps_per_quarter: builtins.int
        """How many quantization steps per quarter note of music."""

        steps_per_second: builtins.int
        """How many quantization steps per second."""

        def __init__(self,
            *,
            steps_per_quarter: builtins.int = ...,
            steps_per_second: builtins.int = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["resolution",b"resolution","steps_per_quarter",b"steps_per_quarter","steps_per_second",b"steps_per_second"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["resolution",b"resolution","steps_per_quarter",b"steps_per_quarter","steps_per_second",b"steps_per_second"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["resolution",b"resolution"]) -> typing.Optional[typing_extensions.Literal["steps_per_quarter","steps_per_second"]]: ...

    class SubsequenceInfo(google.protobuf.message.Message):
        """Information about the location of the sequence in a larger source sequence."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        START_TIME_OFFSET_FIELD_NUMBER: builtins.int
        END_TIME_OFFSET_FIELD_NUMBER: builtins.int
        start_time_offset: builtins.float
        """Time in seconds from the start of the source sequence to the start of
        this sequence.
        """

        end_time_offset: builtins.float
        """Time in seconds from the end of this sequence to the end of the source
        sequence.
        """

        def __init__(self,
            *,
            start_time_offset: builtins.float = ...,
            end_time_offset: builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["end_time_offset",b"end_time_offset","start_time_offset",b"start_time_offset"]) -> None: ...

    class SectionAnnotation(google.protobuf.message.Message):
        """Information about a section within a piece.
        A section is considered to be active from its indicated time until either a
        new section is defined or the end of the piece is reached.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIME_FIELD_NUMBER: builtins.int
        SECTION_ID_FIELD_NUMBER: builtins.int
        time: builtins.float
        """Time in seconds."""

        section_id: builtins.int
        """The id of the section.
        Section ids must be unique within a piece.
        """

        def __init__(self,
            *,
            time: builtins.float = ...,
            section_id: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["section_id",b"section_id","time",b"time"]) -> None: ...

    class Section(google.protobuf.message.Message):
        """A section.
        Either a section_id, which references a SectionAnnotation or a nested
        SectionGroup.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SECTION_ID_FIELD_NUMBER: builtins.int
        SECTION_GROUP_FIELD_NUMBER: builtins.int
        section_id: builtins.int
        @property
        def section_group(self) -> global___NoteSequence.SectionGroup: ...
        def __init__(self,
            *,
            section_id: builtins.int = ...,
            section_group: typing.Optional[global___NoteSequence.SectionGroup] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["section_group",b"section_group","section_id",b"section_id","section_type",b"section_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["section_group",b"section_group","section_id",b"section_id","section_type",b"section_type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["section_type",b"section_type"]) -> typing.Optional[typing_extensions.Literal["section_id","section_group"]]: ...

    class SectionGroup(google.protobuf.message.Message):
        """A group of sections and an indication of how many times to play them.
        Note that a SectionGroup may contain nested SectionGroups. This is to
        capture some of the more complex structure in ABC files with part
        directives like P:((AB)3(CD)3)2.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SECTIONS_FIELD_NUMBER: builtins.int
        NUM_TIMES_FIELD_NUMBER: builtins.int
        @property
        def sections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.Section]: ...
        num_times: builtins.int
        def __init__(self,
            *,
            sections: typing.Optional[typing.Iterable[global___NoteSequence.Section]] = ...,
            num_times: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["num_times",b"num_times","sections",b"sections"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    FILENAME_FIELD_NUMBER: builtins.int
    REFERENCE_NUMBER_FIELD_NUMBER: builtins.int
    COLLECTION_NAME_FIELD_NUMBER: builtins.int
    TICKS_PER_QUARTER_FIELD_NUMBER: builtins.int
    TIME_SIGNATURES_FIELD_NUMBER: builtins.int
    KEY_SIGNATURES_FIELD_NUMBER: builtins.int
    TEMPOS_FIELD_NUMBER: builtins.int
    NOTES_FIELD_NUMBER: builtins.int
    TOTAL_TIME_FIELD_NUMBER: builtins.int
    TOTAL_QUANTIZED_STEPS_FIELD_NUMBER: builtins.int
    PITCH_BENDS_FIELD_NUMBER: builtins.int
    CONTROL_CHANGES_FIELD_NUMBER: builtins.int
    PART_INFOS_FIELD_NUMBER: builtins.int
    SOURCE_INFO_FIELD_NUMBER: builtins.int
    TEXT_ANNOTATIONS_FIELD_NUMBER: builtins.int
    SECTION_ANNOTATIONS_FIELD_NUMBER: builtins.int
    SECTION_GROUPS_FIELD_NUMBER: builtins.int
    QUANTIZATION_INFO_FIELD_NUMBER: builtins.int
    SUBSEQUENCE_INFO_FIELD_NUMBER: builtins.int
    SEQUENCE_METADATA_FIELD_NUMBER: builtins.int
    INSTRUMENT_INFOS_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Unique id."""

    filename: typing.Text
    """The path of the file relative to the root of the collection."""

    reference_number: builtins.int
    """A unique id to differentiate multiple pieces taken from the same input
    file.
    """

    collection_name: typing.Text
    """The collection from which the file comes. This can be shorthand e.g.
    "bach". One purpose is to allow for easy selection of all or some files
    from a particular source.
    """

    ticks_per_quarter: builtins.int
    """MIDI ticks per quarter note, also known as resolution or PPQ ("pulses per
    quarter").
    There is no widely-used default. A default of 220 is assumed per the choice
    made in third_party/py/pretty_midi.
    """

    @property
    def time_signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.TimeSignature]:
        """Lacking a time signature, 4/4 is assumed per MIDI standard."""
        pass
    @property
    def key_signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.KeySignature]:
        """Lacking a key signature, C Major is assumed per MIDI standard."""
        pass
    @property
    def tempos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.Tempo]:
        """Lacking a tempo change, 120 qpm is assumed per MIDI standard."""
        pass
    @property
    def notes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.Note]:
        """A Note combines a MIDI NoteOn and NoteOff into one event with duration."""
        pass
    total_time: builtins.float
    """The total time of the Sequence in seconds.
    Currently the total time is defined as the end time of the last note in the
    sequence, and any control changes or rests that occur after the end of the
    last note are not included in this time.
    Note: In the future, this time will be allowed to extend beyond the last
    note end time in order to represent padding. Magenta.js already uses this
    interpretation of the field.
    TODO(adarob): Update existing code to allow for this new interpretation.
    """

    total_quantized_steps: builtins.int
    """The total time of the sequence in quantized steps.
    This has the same meaning as the total_time field.
    Note: In the future, steps will be allowed to extend beyond the last note
    end steps in order to represent padding. Magenta.js already uses this
    interpretation of the field.
    TODO(adarob): Update existing code to allow for this new interpretation.
    """

    @property
    def pitch_bends(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.PitchBend]:
        """MIDI-specific events that are generally relevant for performance, metadata
        storage or re-synthesis but not for processing the music score.
        """
        pass
    @property
    def control_changes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.ControlChange]: ...
    @property
    def part_infos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.PartInfo]:
        """Score-related information about parts."""
        pass
    @property
    def source_info(self) -> global___NoteSequence.SourceInfo:
        """Source-related information."""
        pass
    @property
    def text_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.TextAnnotation]:
        """Arbitrary textual annotations."""
        pass
    @property
    def section_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.SectionAnnotation]:
        """Annotations indicating sections within a piece."""
        pass
    @property
    def section_groups(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.SectionGroup]:
        """Instructions on how to play back the sections within a piece."""
        pass
    @property
    def quantization_info(self) -> global___NoteSequence.QuantizationInfo:
        """Information about how/if this sequence was quantized."""
        pass
    @property
    def subsequence_info(self) -> global___NoteSequence.SubsequenceInfo:
        """Information about how this sequence was extracted from a larger source
        sequence (if that was the case).
        """
        pass
    @property
    def sequence_metadata(self) -> global___SequenceMetadata:
        """Sequence metadata."""
        pass
    @property
    def instrument_infos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NoteSequence.InstrumentInfo]:
        """information about instrument type."""
        pass
    def __init__(self,
        *,
        id: typing.Text = ...,
        filename: typing.Text = ...,
        reference_number: builtins.int = ...,
        collection_name: typing.Text = ...,
        ticks_per_quarter: builtins.int = ...,
        time_signatures: typing.Optional[typing.Iterable[global___NoteSequence.TimeSignature]] = ...,
        key_signatures: typing.Optional[typing.Iterable[global___NoteSequence.KeySignature]] = ...,
        tempos: typing.Optional[typing.Iterable[global___NoteSequence.Tempo]] = ...,
        notes: typing.Optional[typing.Iterable[global___NoteSequence.Note]] = ...,
        total_time: builtins.float = ...,
        total_quantized_steps: builtins.int = ...,
        pitch_bends: typing.Optional[typing.Iterable[global___NoteSequence.PitchBend]] = ...,
        control_changes: typing.Optional[typing.Iterable[global___NoteSequence.ControlChange]] = ...,
        part_infos: typing.Optional[typing.Iterable[global___NoteSequence.PartInfo]] = ...,
        source_info: typing.Optional[global___NoteSequence.SourceInfo] = ...,
        text_annotations: typing.Optional[typing.Iterable[global___NoteSequence.TextAnnotation]] = ...,
        section_annotations: typing.Optional[typing.Iterable[global___NoteSequence.SectionAnnotation]] = ...,
        section_groups: typing.Optional[typing.Iterable[global___NoteSequence.SectionGroup]] = ...,
        quantization_info: typing.Optional[global___NoteSequence.QuantizationInfo] = ...,
        subsequence_info: typing.Optional[global___NoteSequence.SubsequenceInfo] = ...,
        sequence_metadata: typing.Optional[global___SequenceMetadata] = ...,
        instrument_infos: typing.Optional[typing.Iterable[global___NoteSequence.InstrumentInfo]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["quantization_info",b"quantization_info","sequence_metadata",b"sequence_metadata","source_info",b"source_info","subsequence_info",b"subsequence_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["collection_name",b"collection_name","control_changes",b"control_changes","filename",b"filename","id",b"id","instrument_infos",b"instrument_infos","key_signatures",b"key_signatures","notes",b"notes","part_infos",b"part_infos","pitch_bends",b"pitch_bends","quantization_info",b"quantization_info","reference_number",b"reference_number","section_annotations",b"section_annotations","section_groups",b"section_groups","sequence_metadata",b"sequence_metadata","source_info",b"source_info","subsequence_info",b"subsequence_info","tempos",b"tempos","text_annotations",b"text_annotations","ticks_per_quarter",b"ticks_per_quarter","time_signatures",b"time_signatures","total_quantized_steps",b"total_quantized_steps","total_time",b"total_time"]) -> None: ...
global___NoteSequence = NoteSequence

class SequenceMetadata(google.protobuf.message.Message):
    """Stores metadata associated with a sequence."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TITLE_FIELD_NUMBER: builtins.int
    ARTIST_FIELD_NUMBER: builtins.int
    GENRE_FIELD_NUMBER: builtins.int
    COMPOSERS_FIELD_NUMBER: builtins.int
    title: typing.Text
    """Title of the piece."""

    artist: typing.Text
    """Primary artist of the sequence."""

    @property
    def genre(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Genre(s) of the sequence."""
        pass
    @property
    def composers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Composer of the sequece. Some pieces have multiple composers."""
        pass
    def __init__(self,
        *,
        title: typing.Text = ...,
        artist: typing.Text = ...,
        genre: typing.Optional[typing.Iterable[typing.Text]] = ...,
        composers: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["artist",b"artist","composers",b"composers","genre",b"genre","title",b"title"]) -> None: ...
global___SequenceMetadata = SequenceMetadata

class VelocityRange(google.protobuf.message.Message):
    """Stores an inclusive range of velocities."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MIN_FIELD_NUMBER: builtins.int
    MAX_FIELD_NUMBER: builtins.int
    min: builtins.int
    max: builtins.int
    def __init__(self,
        *,
        min: builtins.int = ...,
        max: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max",b"max","min",b"min"]) -> None: ...
global___VelocityRange = VelocityRange
